/**
 * Generators - Export Format Generators
 * TypeScript, gRPC, JSON Schema generation
 */

class Generators {
    constructor(protoStruct) {
        this.protoStruct = protoStruct;
    }

    /**
     * Generate TypeScript type definitions from protobuf schema
     */
    generateTypeScriptDefinitions() {
        let output = [];
        
        // File header
        output.push('/**');
        output.push(' * TypeScript Type Definitions');
        output.push(' * Generated by LiDa ProtoStruct PRO');
        output.push(` * Generated at: ${new Date().toISOString()}`);
        output.push(' */');
        output.push('');
        
        // Generate interfaces for each message
        const messageArray = Array.from(this.protoStruct.messageDefinitions.values())
            .sort((a, b) => (a.depth || 0) - (b.depth || 0));
        
        messageArray.forEach((message, index) => {
            output.push(`export interface ${message.name} {`);
            
            message.fields.forEach(field => {
                const tsType = this.protoToTypeScriptType(field.type);
                const optional = field.type.includes('optional') ? '?' : '';
                const comment = field.comment ? ` // ${field.comment.replace('//', '').trim()}` : '';
                output.push(`  ${field.name}${optional}: ${tsType};${comment}`);
            });
            
            output.push('}');
            
            if (index < messageArray.length - 1) {
                output.push('');
            }
        });
        
        return output.join('\n');
    }

    /**
     * Convert Protobuf type to TypeScript type
     */
    protoToTypeScriptType(protoType) {
        // Remove 'repeated' keyword
        const isArray = protoType.includes('repeated');
        let baseType = protoType.replace('repeated ', '');
        
        // Map protobuf types to TypeScript types
        const typeMap = {
            'string': 'string',
            'int32': 'number',
            'int64': 'number',
            'uint32': 'number',
            'uint64': 'number',
            'sint32': 'number',
            'sint64': 'number',
            'fixed32': 'number',
            'fixed64': 'number',
            'sfixed32': 'number',
            'sfixed64': 'number',
            'bool': 'boolean',
            'bytes': 'Uint8Array',
            'double': 'number',
            'float': 'number',
            'google.protobuf.Timestamp': 'Date | string',
            'google.protobuf.Duration': 'string',
            'google.protobuf.Any': 'any',
            'google.protobuf.NullValue': 'null'
        };
        
        let tsType = typeMap[baseType] || baseType;
        
        return isArray ? `${tsType}[]` : tsType;
    }

    /**
     * Generate gRPC service definition
     */
    generateGRPCService(serviceName) {
        let output = [];
        
        // File header
        output.push('// gRPC Service Definition');
        output.push('// Generated by LiDa ProtoStruct PRO');
        output.push(`// Generated at: ${new Date().toISOString()}`);
        output.push('');
        
        // Get the first message as the main entity
        const messageArray = Array.from(this.protoStruct.messageDefinitions.values());
        const mainMessage = messageArray[0];
        
        if (!mainMessage) {
            output.push('// No messages available to generate service');
            return output.join('\n');
        }
        
        // Include the original proto definitions
        output.push('syntax = "proto3";');
        output.push('');
        output.push(`package ${serviceName.toLowerCase()}.v1;`);
        output.push('');
        
        // Add imports if needed
        if (this.protoStruct.imports.size > 0) {
            Array.from(this.protoStruct.imports).sort().forEach(imp => {
                output.push(`import "${imp}";`);
            });
            output.push('');
        }
        
        // Include all message definitions
        messageArray.forEach(message => {
            output.push(this.protoStruct.generateMessageDefinition(message));
            output.push('');
        });
        
        // Generate CRUD-style service
        const entityName = mainMessage.name;
        output.push(`service ${serviceName} {`);
        output.push(`  // Create a new ${entityName}`);
        output.push(`  rpc Create${entityName}(Create${entityName}Request) returns (${entityName});`);
        output.push('');
        output.push(`  // Get a ${entityName} by ID`);
        output.push(`  rpc Get${entityName}(Get${entityName}Request) returns (${entityName});`);
        output.push('');
        output.push(`  // Update an existing ${entityName}`);
        output.push(`  rpc Update${entityName}(Update${entityName}Request) returns (${entityName});`);
        output.push('');
        output.push(`  // Delete a ${entityName}`);
        output.push(`  rpc Delete${entityName}(Delete${entityName}Request) returns (Delete${entityName}Response);`);
        output.push('');
        output.push(`  // List ${entityName}s with pagination`);
        output.push(`  rpc List${entityName}s(List${entityName}sRequest) returns (List${entityName}sResponse);`);
        output.push('}');
        output.push('');
        
        // Generate request/response messages
        output.push(`message Create${entityName}Request {`);
        output.push(`  ${entityName} ${this.protoStruct.toSnakeCase(entityName)} = 1;`);
        output.push('}');
        output.push('');
        
        output.push(`message Get${entityName}Request {`);
        output.push('  string id = 1;');
        output.push('}');
        output.push('');
        
        output.push(`message Update${entityName}Request {`);
        output.push('  string id = 1;');
        output.push(`  ${entityName} ${this.protoStruct.toSnakeCase(entityName)} = 2;`);
        output.push('}');
        output.push('');
        
        output.push(`message Delete${entityName}Request {`);
        output.push('  string id = 1;');
        output.push('}');
        output.push('');
        
        output.push(`message Delete${entityName}Response {`);
        output.push('  bool success = 1;');
        output.push('  string message = 2;');
        output.push('}');
        output.push('');
        
        output.push(`message List${entityName}sRequest {`);
        output.push('  int32 page_size = 1;');
        output.push('  string page_token = 2;');
        output.push('  string filter = 3;');
        output.push('}');
        output.push('');
        
        output.push(`message List${entityName}sResponse {`);
        output.push(`  repeated ${entityName} ${this.protoStruct.toSnakeCase(entityName)}s = 1;`);
        output.push('  string next_page_token = 2;');
        output.push('  int32 total_count = 3;');
        output.push('}');
        
        return output.join('\n');
    }

    /**
     * Generate JSON Schema from protobuf definitions
     */
    generateJSONSchema() {
        const messageArray = Array.from(this.protoStruct.messageDefinitions.values());
        const mainMessage = messageArray[0];
        
        if (!mainMessage) {
            return {
                $schema: 'http://json-schema.org/draft-07/schema#',
                type: 'object',
                properties: {}
            };
        }
        
        const schema = {
            $schema: 'http://json-schema.org/draft-07/schema#',
            $id: `${mainMessage.name}.schema.json`,
            title: mainMessage.name,
            description: `JSON Schema for ${mainMessage.name}`,
            type: 'object',
            properties: {},
            required: []
        };
        
        // Convert main message to JSON Schema
        mainMessage.fields.forEach(field => {
            const fieldSchema = this.protoFieldToJSONSchema(field);
            schema.properties[field.name] = fieldSchema;
            
            // Add to required if not optional/repeated
            if (!field.type.includes('optional') && !field.type.includes('repeated')) {
                schema.required.push(field.name);
            }
        });
        
        // Add definitions for nested messages
        if (messageArray.length > 1) {
            schema.definitions = {};
            messageArray.slice(1).forEach(message => {
                schema.definitions[message.name] = this.messageToJSONSchema(message);
            });
        }
        
        return schema;
    }

    /**
     * Convert a protobuf field to JSON Schema property
     */
    protoFieldToJSONSchema(field) {
        const isArray = field.type.includes('repeated');
        let baseType = field.type.replace('repeated ', '').replace('optional ', '');
        
        // Map protobuf types to JSON Schema types
        const typeMap = {
            'string': { type: 'string' },
            'int32': { type: 'integer', format: 'int32' },
            'int64': { type: 'integer', format: 'int64' },
            'uint32': { type: 'integer', format: 'uint32', minimum: 0 },
            'uint64': { type: 'integer', format: 'uint64', minimum: 0 },
            'sint32': { type: 'integer', format: 'int32' },
            'sint64': { type: 'integer', format: 'int64' },
            'fixed32': { type: 'integer', format: 'uint32' },
            'fixed64': { type: 'integer', format: 'uint64' },
            'bool': { type: 'boolean' },
            'bytes': { type: 'string', contentEncoding: 'base64' },
            'double': { type: 'number', format: 'double' },
            'float': { type: 'number', format: 'float' },
            'google.protobuf.Timestamp': { type: 'string', format: 'date-time' },
            'google.protobuf.Duration': { type: 'string', pattern: '^\\d+(\\.\\d+)?s$' },
            'google.protobuf.Any': {},
            'google.protobuf.NullValue': { type: 'null' }
        };
        
        let schema = typeMap[baseType] || { $ref: `#/definitions/${baseType}` };
        
        // Add description from comment
        if (field.comment) {
            schema.description = field.comment.replace('//', '').trim();
        }
        
        // Wrap in array if repeated
        if (isArray) {
            schema = {
                type: 'array',
                items: schema
            };
        }
        
        return schema;
    }

    /**
     * Convert a protobuf message to JSON Schema definition
     */
    messageToJSONSchema(message) {
        const schema = {
            type: 'object',
            properties: {},
            required: []
        };
        
        message.fields.forEach(field => {
            schema.properties[field.name] = this.protoFieldToJSONSchema(field);
            
            if (!field.type.includes('optional') && !field.type.includes('repeated')) {
                schema.required.push(field.name);
            }
        });
        
        return schema;
    }
}